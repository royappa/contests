#include <vector>
#include <list>
#include <map>
#include <set>
#include <deque>
#include <stack>
#include <bitset>
#include <algorithm>
#include <functional>
#include <numeric>
#include <utility>
#include <sstream>
#include <iostream>
#include <iomanip>
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <ctime>
#define UNDEF (-(1<<30))

using namespace std;

class MoneyGame {
public:


int memo[2][6][6][6][6][6][6];

void initMemo()
{

	for (int a = 0; a < 2; a++)
	for (int b = 0; b < 6; b++)
	for (int c = 0; c < 6; c++)
	for (int d = 0; d < 6; d++)
	for (int e = 0; e < 6; e++)
	for (int f = 0; f < 6; f++)
	for (int g = 0; g < 6; g++)
		memo[a][b][c][d][e][f][g] = UNDEF;
}

vector<int> L, F, values, orig;

int f(int p, int L0, int L1, int L2, int F0, int F1, int F2)
{
	int& r = memo[p][L0][L1][L2][F0][F1][F2];
	if (r != UNDEF)
	{
		//cout << p << " " << L0 << " " << L1 << " " << L2 << " " << F0 << " " << F1 << " " << F2 << " = " << r << endl;
		return r;
	}
		
	// what's in the pot is what they have not played

	int lcoins[3], fcoins[3];
	lcoins[0] = L0; lcoins[1] = L1; lcoins[2] = L2;
	fcoins[0] = F0; fcoins[1] = F1; fcoins[2] = F2;
	
	if (p == 0) // Lenny's turn
	{
		if (L0+L1+L2 == 0)
		{
			r = -(F0*values[0]+F1*values[1]+F2*values[2]);
		}
		else
		{
			r = -100000;
			for (int i = 0; i < 3; i++)
			{
				if (lcoins[i] > 0) // Lenny has a coin of this type
				{
					// put in the pot and take out whatever he can
					for (int a = 0; a <= (i==0)?0:(orig[0]-lcoins[0]-fcoins[0]); a++)
					for (int b = 0; b <= (i==1)?0:(orig[1]-lcoins[1]-fcoins[1]); b++)
					for (int c = 0; c <= (i==2)?0:(orig[2]-lcoins[2]-fcoins[2]); c++)
					{
						if (a*values[0]+b*values[1]+c*values[2] < values[i])
						{
							r = max(r, f(1, L0+a-(i==0), L1+b-(i==1), L2+c-(i==2), F0, F1, F2));
						}
					}
				}
			}
		}
	}
	else // p = 1, opposite
	{
		if (F0+F1+F2 == 0)
		{
			r = L0*values[0]+L1*values[1]+L2*values[2];
		}
		else
		{
			r = 100000;
			bool any = false;
			for (int i = 0; i < 3; i++)
			{
				if (fcoins[i] > 0) // Fred has a coin of this type
				{
					// put in the pot and take out whatever he can
					for (int a = 0; a <= (i==0)?0:(orig[0]-lcoins[0]-fcoins[0]); a++)
					for (int b = 0; b <= (i==1)?0:(orig[1]-lcoins[1]-fcoins[1]); b++)
					for (int c = 0; c <= (i==2)?0:(orig[2]-lcoins[2]-fcoins[2]); c++)
					{
						if (a*values[0]+b*values[1]+c*values[2] < values[i])
						{
							r = min(r, f(0, L0, L1, L2, F0+a-(i==0), F1+b-(i==1), F2+c-(i==2)));
						}
					}
				}
			}
		}	
		
	}
	//cout << p << " " << L0 << " " << L1 << " " << L2 << " " << F0 << " " << F1 << " " << F2 << " = " << r << endl;
	return r;
}

int play(vector <int> L_, vector <int> F_, vector <int> values_) 
{
	
	initMemo();

	L = L_;
	F = F_;
	values = values_;
	for (int i = 0; i < 3; i++)
	{
		orig.push_back(L[i]+F[i]);
	}
	return f(0, L[0], L[1], L[2], F[0], F[1], F[2]);
	
}
};



Problem Statement
    
You recently purchased a CD player from Bob's Bargain Barn. As you don't like listening to songs from your CDs in the same order every day, you were very interested in the "Random" button on the CD player. According to the instruction manual, if the CD player has n songs, the "Random" feature works as follows:
Randomly select a permutation of the n songs.
Play the songs in order from that permutation.
Go to step 1.
Based on this algorithm, for 3 songs you could legally obtain "ABCCAB" and "BCABCA", but not "AABBCC".
You are not sure if you trust Bob's Bargain Barn, so you want to figure out if the CD player is broken or not. However, as luck would have it, your sister had started listening to the CD, so you don't know when the next permutation begins. This means that the list "BBAC" could be an acceptable list, if the first B was the last song in the first permutation, and the second B started the second permutation.
You will be given a vector <string> songlist containing the list of songs that you heard. Each distinct character in songlist represents a single distinct song. This should be concatenated to form one string. You will also be given n, the number of songs on your CD. If the entire songlist could have been generated using the above algorithm, return the earliest 0-based index in songlist where a new permutation began. If there are multiple valid indices that could be the start of a permutation, return the smallest of these. If the songlist could not have been generated by the algorithm described above, return -1. See the examples for clarification.
Definition
    
Class:
CDPlayer
Method:
isRandom
Parameters:
vector <string>, int
Returns:
int
Method signature:
int isRandom(vector <string> songlist, int n)
(be sure your method is public)
    

Constraints
-
songlist will contain between 1 and 50 elements, inclusive.
-
Each element of songlist will contain between 1 and 50 characters, inclusive.
-
Each character in songlist will be one of the first n uppercase letters ('A'-'Z').
-
n will be between 1 and 26, inclusive.
Examples
0)

    
{"BBAC"}
3
Returns: 1
The example from the problem statement. The first song cannot be the start of a permutation, since "BBA" is not a permutation of "ABC". However, if the permutation starts at song 1, then "??B" and "BAC" are both valid.
1)

    
{"BACAB",
 "BCA"}
3
Returns: 2
Index 0 is illegal because the second set of songs "ABB" is illegal. Similarly, index 1 can't be a legal start ("BBC" is illegal). Index 2 works though, since "?BA", "CAB", "BCA" could be generated by the algorithm.
2)

    
{"AAACBACBACBACBACBACBACB"}
3
Returns: -1
Even though all of the songs starting at index 2 work, the "?AA" that would have preceded it could not have been generated; thus, the CD player is broken.
3)

    
{"ABCDEABDECBAECDEDACB"}
5
Returns: 0

4)

    
{"ABCABCABCABCABCABCABC",
 "ABCABCABCABCABCABCABC"}
22
Returns: -1

5)

    
{"AAAAAAAAAAAAAAAA",
 "AAAAAAAAAAAAAAAA",
 "AAAAAAAAAAAAAAAA",
 "AAAAAAAAAAAAAAAA",
 "AAAAAAAAAAAAAAAA",
 "AAAAAAAAAAAAAAAA",
 "AAAAAAAAAAAAAAAA",
 "AAAAAAAAAAAAAAAA",
 "AAAAAAAAAAAAAAAA",
 "AAAAAAAAAAAAAAAA"}
1
Returns: 0

6)

    
{"ADEF"}
12
Returns: 0

This problem statement is the exclusive and proprietary property of TopCoder, Inc. Any unauthorized use or reproduction of this information without the prior written consent of TopCoder, Inc. is strictly prohibited. (c)2003, TopCoder, Inc. All rights reserved.